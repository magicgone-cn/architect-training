DDD我最大的困惑就是数据怎么保存？例如一个聚合根的数据从数据库中读取出来，那怎么再把数据保存回数据库呢？如果按照内存中的数据完整的存储回数据库，很可能部分数据已经被其他线程改过了



为什么实际生活中没有锁的概念，而程序中却大量的用锁来解决并发冲突问题呢

假设两个人去仓库取货，那么一个人先把货拿走了，另一个人去拿货的时候自然而然就没有了，拿不到

而在程序世界中，却不是这样的，第一个人拿货的时候，并没有把货给拿走，而只是写个了证明，说这个货的归属是我的；那么当另一个人来拿货的时候，无视了这个已存在的证明（或者因为并发，他看不到这个正在书写的证明），又写了一个证明，说这个货是他的；也就会出现两种情况，要么这个货物上存在两个证明，要么这个货物的证明被后来者改写了，但都不符合实际情况。

现实生活中，也有这种情况，使用虚拟的证明来代表实际的货物，例如房契，来使得货物更好的流通，而这种虚拟化的证明，则需要解决并发的问题。怎么解决的呢？通常是由一个更易于流通的实物，来代替原始的不易流通的实物，例如房契，谁拿到房契，房就是谁的，且这个实物不被伪造。

区块链（或者说比特币）好像就向程序中的这个更易于流通的实物，价值传递在交易过程中就已经同步实现了，不需要有锁来控制并发，只要交易发生，价值也跟随着传递出去，最坏的结果也就是把你扣成负数，永远不会出现，最后一块钱能同时付给两个人，账上的余额还为零。

那么程序世界中能不能也有这种价值传递的方式呢？

例如一个对象定义在内存中，可能很大，也可能很小，占用空间不定，不方便移动。那么能不能有一个固定大小，方便移动的对象来代替这个对象呢？谁拿到这个代替的对象，就有原始对象的所有权。就好像现实世界中的银票和银子的概念。银子不易流通，但银票很方便，且不易伪造。那么程序世界能不能也这样呢？怎么在程序世界中做一个不可复制不可伪造便于移动的东西呢？

程序的数字世界，可能做不到不可复制，因为复制太简单了。但如果允许复制，但复制没有价值呢？借助区块链的概念，采用记账本的概念来传递价值。但记账本是通过链来实现的，查询效率太低，不适用。

换种方式，凭证的唯一性由CPU通过原子操作来保证呢？假设每个对象在分配到内存中的时候，都会同步生成一个秘钥，每当这个对象的归属改变时，就会同步生成新的秘钥，旧秘钥作废，这一步为原子操作。那么并发的时候，两个对象都想获取同一个对象，就会出现，第一个对象得到对象的归属时，同时修改了秘钥，第二对象去获取时，因为是通过旧秘钥去获取，就拿不到了。

如果单纯只用秘钥这一个标识，可能会出现秘钥有限，多个对象的不同时期，使用了同一个秘钥，导致误操作的情况；那么可以增加一个对象ID和秘钥的关联关系，对象ID在一个对象的生命周期内是不变的，对象每次移动，都会生成新的秘钥。

这样就解决了对象移动的问题。

那么对象的属性修改怎么处理呢？

现实世界好像不存在这个问题，是允许并发改的，完全按照先来后到的方式进行覆盖。